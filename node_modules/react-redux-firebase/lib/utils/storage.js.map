{"version":3,"sources":["../../src/utils/storage.js"],"names":["FILE_UPLOAD_ERROR","actionTypes","FILE_UPLOAD_PROGRESS","deleteFile","firebase","path","dbPath","storage","ref","delete","then","database","firestore","metaDeletePromise","_","config","useFirestoreForStorageMeta","doc","remove","createUploadMetaResponseHandler","fileData","uploadTaskSnapshot","downloadURL","metaDataSnapshot","result","snapshot","key","id","File","uploadTaskSnaphot","createdAt","FieldValue","serverTimestamp","ServerValue","TIMESTAMP","getDownloadURLFromUploadTaskSnapshot","getDownloadURL","Promise","resolve","downloadURLs","writeMetadataToDb","options","fileMetadataFactory","metadataFactory","documentId","useSetForMetadata","metaFactoryFunction","metadata","resultFromSnap","documentIdFromOptions","metaSetPromise","docRef","collection","update","set","merge","add","newMetaRef","push","uploadFileWithProgress","dispatch","file","filename","meta","fileMetadata","uploadEvent","put","unListen","on","TaskEvent","STATE_CHANGED","next","type","payload","percent","Math","floor","bytesTransferred","totalBytes","error","err","complete"],"mappings":"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","sourcesContent":["import { omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {object} firebase - Internal firebase object\n * @param {object} settings - Settings object\n * @param {string} settings.path - Path to File which should be deleted\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @returns {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase.firestore().doc(dbPath).delete() // file meta in Firestore\n          : firebase.database().ref(dbPath).remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param {object} settings - Settings object\n * @param {object} settings.fileData - File data which was uploaded\n * @param {object} settings.uploadTaskSnapshot - Snapshot from storage upload task\n * @param {object} settings.firebase - Firebase instance\n * @param {string} settings.downloadURL - Download url\n * @returns {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @returns {object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\n/**\n * Get download URL from upload task snapshot\n * @param {firebase.storage.UploadTaskSnapshot} uploadTaskSnapshot - Upload task snapshot\n * @returns {Promise} Resolves with download URL\n */\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {object} settings - Settings object\n * @param {object} settings.firebase - Internal firebase object\n * @param {object} settings.uploadTaskSnapshot - Snapshot from upload task\n * @param {string} settings.dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @param {object} settings.options - Options object\n * @returns {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory, documentId, useSetForMetadata } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    (downloadURL) => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData =\n        typeof metaFactoryFunction === 'function'\n          ? metaFactoryFunction(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      // Function for creating promise for writing file metadata (handles writing to RTDB or Firestore)\n      const documentIdFromOptions =\n        typeof documentId === 'function'\n          ? documentId(\n              uploadTaskSnapshot,\n              firebase,\n              uploadTaskSnapshot.metadata,\n              downloadURL\n            )\n          : documentId\n      const metaSetPromise = (fileData) => {\n        if (useFirestoreForStorageMeta) {\n          if (documentIdFromOptions) {\n            const docRef = firebase // Write metadata to Firestore\n              .firestore()\n              .collection(dbPath)\n              .doc(documentIdFromOptions)\n            return useSetForMetadata === false\n              ? docRef.update(fileData).then(() => docRef)\n              : docRef.set(fileData, { merge: true }).then(() => docRef)\n          }\n          return firebase.firestore().collection(dbPath).add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase.database().ref(dbPath).push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then((res) => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {object} firebase - Internal firebase object\n * @param {object} opts - File data object\n * @param {object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @param {object} opts.fileMetadata - Metadata to pass along to storageRef.put call\n * @param {object} opts.meta - Meta object\n * @returns {Promise} Promise which resolves after file upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta, fileMetadata }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file, fileMetadata)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: (snapshot) => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            (snapshot.bytesTransferred / snapshot.totalBytes) * 100\n          )\n        }\n      })\n    },\n    error: (err) => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"],"file":"storage.js"}